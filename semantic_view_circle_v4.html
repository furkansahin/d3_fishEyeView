<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Wine Investigator SVG</title>
<link rel="stylesheet" href="css/thumbnailviewer.css" type="text/css" />
<link rel="stylesheet" href="css/semanticfishviewer.css" type="text/css" />
<link type="text/css" href="css/jquery-ui-1.8.24.custom/css/dark-hive/jquery-ui-1.8.24.custom.css" rel="stylesheet" />

<script type="text/javascript" src="javascripts/jquery.js"></script>
<script type="text/javascript" src="javascripts/CustomTooltip.js"></script>
<script type="text/javascript" src="javascripts/clustering.js"></script>
<script type="text/javascript" src="javascripts/thumbnailviewer.js"></script>
<script type="text/javascript" src="javascripts/d3.v2.js"></script>

<script type="text/javascript" src="javascripts/jquery.ui.touch-punch.min.js"></script>
<script type="text/javascript" 	src="javascripts/jquery-ui-1.8.24.custom/js/jquery-1.8.2.min.js"></script>
<script type="text/javascript" 	src="javascripts/jquery-ui-1.8.24.custom/js/jquery-ui-1.8.24.custom.min.js"></script>
<script type="text/javascript" src="javascripts/ddaccordion.js"></script>

<script type="text/javascript" src="javascripts/utility.js"></script>

<script type="text/javascript">
ddaccordion.init({
	headerclass: "expandable", //Shared CSS class name of headers group that are expandable
	contentclass: "categoryitems", //Shared CSS class name of contents group
	revealtype: "click", //Reveal content when user clicks or onmouseover the header? Valid value: "click", "clickgo", or "mouseover"
	mouseoverdelay: 200, //if revealtype="mouseover", set delay in milliseconds before header expands onMouseover
	collapseprev: false, //Collapse previous content (so only one open at any time)? true/false 
	defaultexpanded: [0], //index of content(s) open by default [index1, index2, etc]. [] denotes no content
	onemustopen: false, //Specify whether at least one header should be open always (so never all headers closed)
	animatedefault: false, //Should contents open by default be animated into view?
	persiststate: true, //persist state of opened contents within browser session?
	toggleclass: ["", "openheader"], //Two CSS classes to be applied to the header when it's collapsed and expanded, respectively ["class1", "class2"]
	togglehtml: ["prefix", "", ""], //Additional HTML added to the header when it's collapsed and expanded, respectively  ["position", "html1", "html2"] (see docs)
	animatespeed: "fast", //speed of animation: integer in milliseconds (ie: 200), or keywords "fast", "normal", or "slow"
	oninit:function(headers, expandedindices){ //custom code to run when headers have initalized
		//do nothing
	},
	onopenclose:function(header, index, state, isuseractivated){ //custom code to run whenever a header is opened or closed
		//do nothing
	}
})
</script>


</head>
<body>
	<div id="top-tools">
		<!-- search tool-->
		<script>
	$.widget("custom.catcomplete", $.ui.autocomplete, {
		_renderMenu: function( ul, items ) {
			var self = this,
				currentCategory = "";
			
			//order items according to their categories
			items.sort(function(a,b){
				attr_a = a.category;
				attr_b = b.category;
				
				if(attr_a < attr_b) return -1;
				else if(attr_a > attr_b) return 1;
				return 0;				
			});
			////
				
				
			$.each( items, function( index, item ) {				
				if ( item.category != currentCategory ) {
					ul.append( "<li class='ui-autocomplete-category'>" + item.category + "</li>" );
					currentCategory = item.category;
				}
				self._renderItem( ul, item );
			});
		}
	});
	
	$(function() {
		var accentMap = {
			"á":"a",
			"â":"a",
			"à":"a",		
			"ä":"a",
			
			"ö":"o",
			"ô":"o",			
			"î":"i",
			"ï":"i",			

			"é":"e",
			"ë":"e",
			"è":"e",
			"ê":"e",
			
			"œ":"ce",
			"ù":"u",			
			"û":"u",
			"ü":"u",			
			"ÿ":"y",
						
			"ç":"c"			
		};
		
		var normalize = function( term ) {
			var ret = "";
			for ( var i = 0; i < term.length; i++ ) {
				ret += accentMap[ term.charAt(i) ] || term.charAt(i);
			}
			return ret;
		};

		$.ajax({
			url: "data/items_200.xml",
			dataType: "xml",
			success: function( xmlResponse ) {
				var data = $( "item", xmlResponse ).map(function() {
					var country = "";
					$(this).find("attribute").each(function(){
						if($(this).find("attName").text() == "country"){ country = $(this).find("attValue").text();}
					});
					if(country != "")country = ", " + country;
					
					
					return {
						value: $( "name", this ).text() + country,
						id: $( "id", this ).text(),
						category:$( "genre", this ).text() ||""
					};
				}).get();
				$( "#searchtext" ).catcomplete({
					delay:0,
					//source: data,
					minLength: 2,
					select: function( event, ui ) {
						var node = semanticview.findNode(ui.item.id);
						console.log("Selected:" + node.name+ "(" + node.id + ")");			
						semanticview.resetShowKeyword();			
						semanticview.resetRoot(node);
						$( "#searchtext" ).blur();
						//console.log( ui.item ?
						//	"Selected: " + ui.item.value + ", Id: " + ui.item.id :"Nothing selected, input was " + this.value );
					},
					source: function( request, response ) {
						var matcher = new RegExp( $.ui.autocomplete.escapeRegex( request.term ), "i" );
						response( $.grep( data, function( item ) {
						value = item.value;
						category = item.category;
						return matcher.test(value) || matcher.test(normalize( value )) || matcher.test(category) || matcher.test(normalize(category));;
						}));
					}
				});
			}
		});
	});
	</script>
		<div align="right">
			<div class="ui-widget">
				<input id="searchtext" placeholder="Input Search Texts" />
				<!-- <input id="searchtext" style="width:300px;"/>-->
				<!-- <img src="images/search.png" width="23" height="23" style=" vertical-align:bottom">-->
				<!-- <input id="searchbtn" type="button" value="Search" />-->


			</div>
		</div>
	</div>
	<!-- end of search tool-->

	<!-- community tool-->
	<script>
	$(function() {
		$( "#slider-range-min" ).slider({
			range: "min",
			value: 5,
			min: 0,
			max: 30,
			slide: function( event, ui ) {
				$( "#amount" ).text( ui.value );
				//add actions
				semanticview.redetermineGroup(ui.value);
				semanticview.redraw(1);				
				//
			}
		});
		
		$( "#amount" ).text( $( "#slider-range-min" ).slider( "value" ) );
	});
</script>

	<div class="community-control" style="margin: 5px 0px;">
		<table cellpadding="0" cellspacing="0">
			<tr>
				<!--<td style=" vertical-align:top;"><input id="communityEnableBtn" type="button" value="Enable" style="width:100px"></td>-->
				<!-- <td><label style="border:0; color:#f6931f; font-weight:bold; font-size:13px;">Community: </label></td>
      <td><div id="slider-range-min" style=" width:500px; height:8px; margin:0px 10px;"></div></td>
      <td><!--<label style="color:#f6931f; font-weight:bold; font-size:13px; border:0;">Threshold:</label>-->
				<!--<label id="amount" style="border:0; color:#f6931f; font-weight:bold; font-size:13px;"></label></td>-->
			</tr>
		</table>
	</div>
	<!-- End community-control -->

	</div>
	<!-- End top-tools-->


	<table width="100%" cellpadding="0" cellspacing="0">
		<tr>
			<td><div id="viewer"></div></td>
			<td style="vertical-align: top">



				<div class="arrowlistmenu" id="critiquingtool">

					<h3 class="menuheader expandable">Product Information</h3>
					<div class="categoryitems" id="product_panel"></div>

					<h3 class="menuheader expandable">Recommendation Tunner</h3>
					<div class="categoryitems" id="tunner_panel"></div>


					<h3 class="menuheader expandable">Social Network</h3>
					<div class="categoryitems" id="social_panel"></div>


				</div>

			</td>

		</tr>
	</table>



	<!--
<span>
<input type="button" value="Category" style="width:100px">
<input type="button" value="Country" style="width:100px">
<input type="button" value="Year" style="width:100px">
</span>
-->
	<script type="text/javascript" charset="utf-8">
var full_attributes_list = ["name","genre","price","producer","servingNote","productionNote","degustationNote","storageNote","matchingFood","sellArgument","family", "rating","region","country","grapeTypes"]

//var critiquing_attributes_list = ["name","genre","price","producer","servingNote","productionNote","degustationNote","storageNote","matchingFood","sellArgument","family", "rating","region","country","grapeTypes"]


function showProductPanel(data){
	var content = "";
	if(data){
		content = "<table width=\"100%\" height=\"100%\" cellpadding=\"0\" cellspacing=\"0\">";
	 	content += "<tr>";
	 	content += "<td class=\"productimg\"><img src = \"" + data.img + "\" width=\"40\"  ></td>"
	 	content += "<td style=\"padding-left:10px\">";	 
	 	content += "<table width=\"100%\"  cellpadding=\"0\" cellspacing=\"0\">";
		
	 	content += "<tr class=\"odd\"><td width=\"35%\" class=\"name\">Name:</td><td class=\"value\">";
		content +=  data.name?data.name:"";
		content += "</td></tr>";
		
	 	content += "<tr class=\"even\" ><td class=\"name\">Grape(s):</td><td class=\"value\">" ;		
		content += data.grapeTypes?data.grapeTypes:"";
		content +="</td></tr>";
		
	 	content += "<tr class=\"odd\"><td class=\"name\">Country:</td><td class=\"value\">" ;
		content +=  data.country?data.country:"";
		content += "</td></tr>";
		
	  	content += "<tr class=\"even\"><td class=\"name\">Region:</td><td class=\"value\">";
		content +=  data.region?data.region:"";
		content += "</td></tr>";
		
	 	content += "<tr class=\"odd\"><td class=\"name\">Type:</td><td class=\"value\">";
		content += data.genre?data.genre:"";
		content += "</td></tr>";
		
		content += "<tr class=\"even\"><td class=\"name\">Producer:</td><td class=\"value\">";
		content +=  data.producer?data.producer:"";
		content += "</td></tr>";
		
		content += "<tr class=\"odd\"><td class=\"name\">Matching Food:</td><td class=\"value\">";
		content += data.matchingfood?data.matchingfood:"";
		content += "</td></tr>";
			 		
		content += "<tr class=\"even\"><td class=\"name\">Price:</td><td class=\"value\">";
		content +=  data.price?data.price:"";
		content += " CHF</td></tr>";			
		
		content += "<tr class=\"odd\"><td class=\"name\">Rating:</td><td class=\"value\">";
		content +=  data.rating?data.rating:"";
		content += "</td></tr>";
			 	
		content += "</table></td>";
		content += "</tr></table>";		
	}
	$("#product_panel").html(content);
}



function switch_onoff(event){

var browser=navigator.appName;
	if(browser=="Microsoft Internet Explorer"){		
		target = event.srcElement;			
	}
	else{
		target = event.target;
	}	
	
	if(target.className== "switch_off_button"){
		target.src = "images\\switch_green.png";
		target.className = "switch_on_button"
	}else{
		target.src = "images\\switch_red.png";
		target.className = "switch_off_button"
	}
	
}

var filters = {};


function showCritiquingPanel(data){
	filters = {};
	var critiquing_attributes_list = [	
	  {"label": "Country",  //country
	  "id": "country",
	  "type":"string",
	  "condition":{"Same":"eq","Different":"diff"}
	  },
	 {"label": "Region",  //region
	  "id": "region",
	  "type":"string",
	  "condition":{"Same":"eq","Different":"diff"}
	  },
	 {"label": "Type", //family
	  "id": "family",
	  "type":"string",
	  "condition":{"Same":"eq","Different":"diff"}
	  },
	 {"label": "Producer",  //producer
	  "id": "producer",
	  "type":"string",
	  "condition":{"Same":"eq","Different":"diff"}
	  },
	 {"label": "Price", //price
	  "id": "price",
	  "type":"value",
	  "condition":{"Lower":"lt", "Similar": "round", "Higher":"gt"}
	  },
	 {"label": "Rating", //rating
	  "id": "rating",
	  "type":"value",
	  "condition":{"Lower":"lt", "Equal": "eq", "Higher":"gt"}
	  }
	  ];

	var content = "";
	if(data){
	 	content += "<table width=\"100%\"  cellpadding=\"0\" cellspacing=\"0\" class=\"critiquing\">";
		
		critiquing_attributes_list.forEach(function(element, index){
			if(data[element.id]){
				content += "<tr class=\"";
				if(index%2 == 0) content += "even";
				else content += "odd";
				content += "\" ><td  width=\"21%\"  class=\"name\">" + element.label +":</td>";
				content += "<td><form><div id=\"radio_" + element.id  + "\" >";
				
				content += "<input type=\"radio\" id=\"radio1_" + element.id+ "\" name=\"" + element.id + "\" checked=\"checked\"/><label for=\"radio1_" + element.id + "\">Off</label>";
				
				var i = 2;		
				for (var k in element.condition) {		
					content += "<input type=\"radio\" id=\"radio" + i+ "_" + element.id  + "\" name=\"" + element.id+ "\" /><label for=\"radio" + i+ "_" + element.id  + "\">" + k+ "</label>";
					i++;
				}
				content += "</div></form></td>";
				content +="</tr>";
			}
		});
		content += "</table>";
	}
	$("#tunner_panel").html(content);
	//$("#grape_slider").slider({ from: 0, to: 1, step: 1, round: 1, scale:[0,1],format: { format: '##.0', locale: 'de' }, dimension: '&nbsp;&nbsp;€', skin: "round" });
	
	critiquing_attributes_list.forEach(function(element, index){
			if(data[element.id]){
				$( "#radio_" + element.id ).buttonset();
				for(var i = 1; i< Object.keys(element.condition).length + 2; i++){
					$("#radio"+ i + "_" + element.id).click(
						function(){
							var condition_key = $(this).next().text();
							var condition_value = element.condition[condition_key]?element.condition[condition_key]:"-1";
							//else condition_value = "-1";
							filters[element.id] = {};
							filters[element.id]["value"] = condition_value;
							filters[element.id]["type"] = element.type;				
							semanticview.filter(data, filters);
						}
					);				
				}// end of for
			}
		});
}






SemanticView = function(elemid, options){
	var self = this;
	
	var margin = {top:10, right:10, bottom:10, left:10},
		padding = {top:10, right:10, bottom:10, left:10},
		width =  $(document).width() - $("#critiquingtool").width()  - 2*margin.left ; //     
		height = $(document).height() - $("#top-tools").height() - margin.bottom;  
		
		$("#viewer").css('width', $(document).width() - $("#critiquingtool").width() - 2*margin.left  ); 
		
		this.width = width;
		this.height = height;
		
	var off = 20,    // cluster hull offset
		data, net={}, hull,link, node,root;
		
	var categories=[];
	var node_width = 30;
	var node_height = 57;
	var node_radius = 10;
	
	var img,text;
	
	
	//drag x-axis logic
	this.downx = Math.NaN;
	//drag y-axis logic
	this.downy = Math.NaN;
	
	this.dragged = this.selected = null;
	
	
	// -------------------------------------------------------
	
	var tooltip = CustomTooltip("tooltip", 270);
	
	
	
	vis = d3.select("#viewer").append("svg:svg")
	   		.attr("width", width )
	   		.attr("height", height )
	   		.attr("pointer-events","all")
	  		.append("svg:g")
	  		.call(d3.behavior.zoom().on("zoom", scale_translate))
	  		.on("dblclick.zoom", null)
	  		.append("svg:g");
	   
	var plot = vis.append("rect")
				  .attr("width", 7*width)
				  .attr("height", 7*height)
				  .attr("x", -3*width)
				  .attr("y", -3*height)
				  .attr("opacity",0)
				  .on("mousedown.drag",mousedown)
				  .on("mouseup.drag", mouseup)
				  .on("touchstart.drag",mousedown)
				  .on("touchend.drag", mouseup);
  
	var screen_translation = {x:0, y:0};
	var screen_scale = 0;
	
	var center ={x:width/2, y:height/2};
	var center_pre = {x:0,y:0};
	
	var draw_hull = false;
	var first_draw_hull = true;
	
	this.setDrawHull = function(flag){
		if(draw_hull == false && flag == true) first_draw_hull = true;
		draw_hull = flag;	
	}
	
	this.getDrawHull = function(){
		return draw_hull;
	}
	
	function filter(anchor_point, filters){

		var range = 10;
		//console.log(criteria + "[" + condition_key + ":" + condition_value + "]");		
	
		 var filteredData = net.nodes.filter(function(d){
		 	var flag = true;
			for(var criteria in filters){
				var condition_value = filters[criteria]["value"];	
				var condition_type = filters[criteria]["type"];				
			//	console.log(criteria + ": " + condition_value );	
				switch(condition_value)
				{
					case "eq": 	{
												if(condition_type == "string") flag = flag && (d[criteria]?d[criteria].toLowerCase():d[criteria]) == (anchor_point[criteria]?anchor_point[criteria].toLowerCase():anchor_point[criteria]); 
												else if(condition_type == "value" && criteria == "rating"){ 
												if(d[criteria]){
														var value1 = d[criteria].replace("+","").match(/([0-9|]+\/[0-9]+)/g);
														var value2 = anchor_point[criteria].replace("+","").match(/([0-9|]+\/[0-9]+)/g);
														console.log(value1 + ":::" + d[criteria]);
														if(value1 && value2) {
														value1 = value1[0].split("/");
														value1 = parseFloat(value1[0])/parseFloat(value1[1]);
														
														value2 = value2[0].split("/");
														value2 = parseFloat(value2[0])/parseFloat(value2[1]);
														flag = flag &&value1 == value2; 	
														}
														else flag = false;														
													}
													else flag = false;								
												}												
												break;
												}
					case "diff": 	{	if(condition_type == "string") flag = flag && (d[criteria]?d[criteria].toLowerCase():d[criteria]) != (anchor_point[criteria]?anchor_point[criteria].toLowerCase():anchor_point[criteria]); 
												else if(condition_type == "value"){ 
														if(d[criteria]){
														var value1 = d[criteria].replace("+","").match(/([0-9|]+\/[0-9]+)/g);
														var value2 = anchor_point[criteria].replace("+","").match(/([0-9|]+\/[0-9]+)/g);
														console.log(value1 + ":::" + d[criteria]);
														if(value1 && value2) {
														value1 = value1[0].split("/");
														value1 = parseFloat(value1[0])/parseFloat(value1[1]);
														
														value2 = value2[0].split("/");
														value2 = parseFloat(value2[0])/parseFloat(value2[1]);
														flag = flag &&value1 != value2; 	
														}
														else flag = false;														
													}
													else flag = false;									
												}												
												break;
												}
					case "lt": { if(condition_type == "value" && criteria == "rating"){ 
													if(d[criteria]){
														var value1 = d[criteria].replace("+","").match(/([0-9|]+\/[0-9]+)/g);
														var value2 = anchor_point[criteria].replace("+","").match(/([0-9|]+\/[0-9]+)/g);
														console.log(value1 + ":::" + d[criteria]);
														if(value1 && value2) {
														value1 = value1[0].split("/");
														value1 = parseFloat(value1[0])/parseFloat(value1[1]);
														
														value2 = value2[0].split("/");
														value2 = parseFloat(value2[0])/parseFloat(value2[1]);
														flag = flag &&value1 < value2; 	
														}
														else flag = false;														
													}
													else flag = false;									
												}else {	
														flag = flag && parseFloat(d[criteria]) < parseFloat(anchor_point[criteria]); 
												}
												break;
												}
											
					case "gt" :{ if(condition_type == "value" && criteria == "rating"){ 
													if(d[criteria]){
														var value1 = d[criteria].replace("+","").match(/([0-9|]+\/[0-9]+)/g);
														var value2 = anchor_point[criteria].replace("+","").match(/([0-9|]+\/[0-9]+)/g);
														console.log(value1 + ":::" + d[criteria]);
														if(value1 && value2) {
														value1 = value1[0].split("/");
														value1 = parseFloat(value1[0])/parseFloat(value1[1]);
														
														value2 = value2[0].split("/");
														value2 = parseFloat(value2[0])/parseFloat(value2[1]);
														flag = flag &&value1 > value2; 	
														}
														else flag = false;														
													}
													else flag = false;										
												}else {	
														flag = flag && parseFloat(d[criteria]) > parseFloat(anchor_point[criteria]); 
												}
												break;
												}
					case "round": flag = flag && (parseFloat(d[criteria]) > parseFloat(anchor_point[criteria]) - range && parseFloat(d[criteria]) < parseFloat(anchor_point[criteria]) + range); break;
					default: 
				}					
		 	}
			return !flag;		
		});

		
		nodeg.selectAll("circle.node")
					.data(net.nodes,  function(d){return d.id;})
					.attr("r",function(d){d.visible = true; return d.r;});   
		
		nodeg.selectAll("circle.node")
					.data(filteredData,  function(d){return d.id;})
					.attr("r",function(d){if(d.id == anchor_point.id) return d.r; else {d.visible = false; return 0;}});   
					
		
		textg.selectAll("text.node")
				   .data(net.nodes, function(d){return "title"+d.id})
				   .text(function(d){
			if((screen_scale > 0 && screen_scale * d.r > node_text_threshold) || (screen_scale == 0 && d.r > node_text_threshold))return html_entity_decode(d.name); 
			else return "";
			});
			
		textg.selectAll("text.node")
				   .data(filteredData, function(d){return "title"+d.id})
				   . text(function(d){	
				   				if(d.id == anchor_point.id) {															
									if((screen_scale > 0 && screen_scale * d.r > node_text_threshold) || (screen_scale == 0 && d.r > node_text_threshold)) return html_entity_decode(d.name); 
									else return "";						
								}
								else {						
								return "";
								}
					});
					
		linkg.selectAll("line.link")
				  .data(net.links, function(d){return linkid(d)})
				  .style("stroke-width", function(d) { 
				  		if(d.source.visible && d.target.visible)return d.size?d.size:1;
						else return 0; 
				  });
	}
	
	this.filter= filter;

	function scale_translate(){	
		vis.attr("transform", "translate(" + d3.event.translate + ")" + " scale(" + d3.event.scale + ")");
		
		center.x = (width/2 - d3.event.translate[0])/d3.event.scale ;
		center.y = (height/2 - d3.event.translate[1])/d3.event.scale;
			
		//console.log('d3.event:'+d3.event.translate[0]+':'+d3.event.translate[1]);
			
		screen_translation.x = d3.event.translate[0];
		screen_translation.y = d3.event.translate[1];
		screen_scale = d3.event.scale;	
		
		var depth = net.depth;
		text = textg.selectAll("text.node");
		text.text(function(d){
			if(d.id == net.root.id)d.r = Math.max(Math.ceil(node_radius * Math.pow(2, 1.5)),2); 
			else d.r = Math.max(Math.ceil(node_radius * Math.pow(2, 1- d.depth/depth)),2); 
			if(((screen_scale > 0 && screen_scale * d.r > node_text_threshold) || (screen_scale == 0 && d.r > node_text_threshold))  && d.visible == true)return html_entity_decode(d.name); 
			else return "";
		}); 
	}


	vis.attr("opacity", 1e-6)
	   .transition()
	   .duration(1000)
	   .attr("opacity", 1);
	   
	var hullg = vis.append("g");
		linkg = vis.append("g"),
		keyword_linkg = vis.append("g"),
		nodeg = vis.append("g"),
		imgg = vis.append("g"),
		textg = vis.append("g"),
		keyword_nodeg = vis.append("g"),
		keyword_textg = vis.append("g");
	   
	var force = d3.layout.force()
		  .size([width, height]);
		  
	var force_k = d3.layout.force()
		  .size([width, height]);
	  
	function convexHulls(nodes, index, offset) {
		var hulls = {};
		var sizes = [];
		
		// create point sets
		for (var k=0; k<nodes.length; ++k) {
			var n = nodes[k];
			if (n.size) continue;
			var i = index(n),
				l = hulls[i] || (hulls[i] = []);
			l.push([n.x-offset, n.y-offset]);
			l.push([n.x-offset, n.y+offset]);
			l.push([n.x+offset, n.y-offset]);
			l.push([n.x+offset, n.y+offset]);
		
			var s = sizes[i] || (sizes[i] = 0);
			s++;
			sizes[i] = s;
		}
	
	  	// create convex hulls
	  	var hullsv = [];
	
	  	for (i in hulls) {
			if(sizes[i] == 1) continue;
			hullsv.push({group: i, path: d3.geom.hull(hulls[i])});
		}
		return hullsv;
	}

	function drawCluster(d) {
		return curve(d.path); // 0.8
	}
	  
	var rootIndex = 8;
	var cluster_tree;
	
	var nodes_table = {};
	var node_groups = {};
	var groupIds = [];
	
	
	var group_depth = 21;//20
	this.group_depth = group_depth
	this.graph_depth = 0;
	
	
	function getGroupId(n){
		return n.groupId;
	}
	
	function getNodeIndex(id){
		return nodes_table[id];
	}

	function assignGroup(nodes, tree, groupId){
		if(tree.size > 1){
			if(tree.left != null)assignGroup(nodes, tree.left, groupId);
			if(tree.right != null) assignGroup(nodes, tree.right, groupId);		
		}else{		
			nodes[getNodeIndex(tree.label)].groupId = groupId;
		}
		
	}
	
	function determineGroup(nodes, tree, group_depth){
		if(tree.depth > group_depth){
			determineGroup(nodes, tree.left, group_depth);
			determineGroup(nodes, tree.right, group_depth);
		}else if(tree.depth == group_depth){
			if((tree.left != null && tree.left.depth == group_depth) || (tree.right != null && tree.right.depth == group_depth)) {
				determineGroup(nodes, tree.left, group_depth);
				determineGroup(nodes, tree.right, group_depth);
			}else{
				assignGroup(nodes, tree, groupIds.length);
				groupIds.push(groupIds.length);
			}
		}else{
			assignGroup(nodes, tree, groupIds.length);
			groupIds.push(groupIds.length);
		}
	}
	
	var keyword_data;

	//function:init
	function init(){
		d3.json("data/keywords_200.json", function(json){
			keyword_data = json;
		});
			
	
		d3.json("data/items_200.json", function(json){
			data = json;
			var labels = [];
			var vectors = [];
			var weights = [1,1,1,1,1];
			
			for(var k = 0; k < data.nodes.length; k++){
				var n = data.nodes[k];
				n.visible = true;
				nodes_table[n.id] = k;
				var cIndex = jQuery.inArray(n.genre, categories);
				if(cIndex < 0) {
					categories.push(n.genre);
				}
				labels.push(n.id);
	  			//var vector = [n.genre,n.country,n.region,n.greapeTypes,n.year];
	  			//vectors.push(vector);				
			} 
	
			var links = [];
	
			for(var k = 0; k < data.links.length; k++){
		  		var e = data.links[k];
		  		if(e.value > 3) {links.push(e);}
			}
			data.links = links;
			
			/*var cluster_tree = clustering.agglomerateWithWeight(labels,
										 vectors,
										 weights,
										 clustering.EUCLIDIAN_DISTANCE,
										 clustering.SINGLE_LINKAGE
										 );
										 
	  		*/								   
			cluster_tree = clustering.agglomerateWithDistance(labels,
															  data.links,
										 					  clustering.SINGLE_LINKAGE
															  );

			//console.log(cluster_tree);
			assignGraphDepth(cluster_tree.depth);
			$( "#slider-range-min" ).slider( "option", "max", self.graph_depth);
			$( "#slider-range-min" ).slider( "option", "value", group_depth);
		
			$( "#amount" ).text( $( "#slider-range-min" ).slider( "value" ) );
	
			groupIds = [];
			determineGroup(data.nodes, cluster_tree, group_depth);	  
		//	console.log(groupIds);
			
			for (var i=0; i<data.links.length; ++i) {
				var o = data.links[i];
				o.source = data.nodes[o.source];
				o.target = data.nodes[o.target];
			}
			
			root = data.nodes[rootIndex];
			root.x = width/2;
			root.y = height/2;
			
			resetRoot(root);
			//redraw(0);
		});
	}//end of init()

	function assignGraphDepth(depth){	
		self.graph_depth = depth;	
	}
	
	this.getGraphDepth = function(){
		return this.graph_depth;
	}
	
	
	function redetermineGroup(gdepth){
		group_depth = gdepth;
		groupIds = [];
		determineGroup(net.nodes, cluster_tree, group_depth);
	};
	
	var curve = d3.svg.line()
					  .interpolate("cardinal-closed")
					  .tension(0.8);
	
	var fill = function(index){return colors[index];} //d3.scale.category20b();
	
	var colors = [ '#C0C0FF', '#C0FFFF','#C0FFC0','#FFFFC0', '#FF40FF', '#40C0FF', '#40FFFF','#C0FF40','#40FF00','#FFFF40','#C080FF','#80C0C0','#40FFC0','#80C000','#FFC0C0','#C000FF','#0080FF','#00C0C0','#80FF80','#00C000','#FFC040','#8000FF','#0040FF','#008080','#40FF80','#FF8080','#C080C0','#8080C0','#00FF40','#FF8000','#C000C0','#0080C0','#80C040','#FF4000','#8000C0','#0040C0','#00C080','#C0C080','#804080','#404080','#C0C000','#C08040','#C04040','#C00000','#808000','#804000'];
	
	function nodeid(n) {
		return n.size ? "_g_"+n.group : n.name;
	}
	
	function linkid(l) {
		var u = l.source.id, v = l.target.id;
		return u<v ? u+"|"+v : v+"|"+u;
	}

	function print_r(root){
		var text = '';
		for(var attr in root){
			text += attr + ':' + root[attr] + ', ';
		}
		alert(text);	
	}

	//function: network() - constructs the network to visualize
	function network(data, prev,root) {
		var nodes = [], // output nodes
			links = [],  // output links
			t_links = [],
			t_links_1 = [],
			nodes_id = [];
			
		//	for(var j = 0; j < data.nodes.length;j++){console.log(j+":"+data.nodes[j].id);	}
		
			
		var depth;
	
		prev = prev || {};
		if(prev.root)prev.root.fixed = false;
		
		root.fixed = true;	
		root.depth = 0;	
		
		nodes.push(root);
		nodes_id.push(root.id);
		
		for(var k = 0; k < data.links.length; k++){
			var e = data.links[k];
			if(e.value > 0) {t_links.push(e);t_links_1.push(e);}
		}
		
		var full_node_id = [];
		
		for(var k = 0; k < data.nodes.length; k++){
			var n = data.nodes[k];
			n.visible = true;	
			full_node_id.push(n.id);		
		}	
		
		var sIndex, tIndex, sId, tId;		
		for(var d = 0; nodes.length != data.nodes.length; d++){
			depth = d + 1;
		
	
			var tt_links = [], tt_nodes = []; tt_nodes_id = [];
			for(var k = 0; k < t_links.length; k++){
				var e = t_links[k];			
				if(typeof e.source == 'object'){
					sId = e.source.id;
					tId = e.target.id;				
				} 
				else{
					sId = data.nodes[e.source].id;
					tId = data.nodes[e.target].id;				
				}
				
				
				sIndex = jQuery.inArray(sId, nodes_id);
				tIndex = jQuery.inArray(tId, nodes_id);	
				if(sIndex >= 0){				
					if(tIndex < 0  && jQuery.inArray(tId, tt_nodes_id) < 0){							
						tt_nodes.push(data.nodes[jQuery.inArray(tId, full_node_id)]);
						tt_nodes_id.push(tId);			
						tt_links.push(e);				
					}
					else{
						//tt_links.push(e);
					}
									
				}else if(tIndex >= 0  &&  jQuery.inArray(sId, tt_nodes_id) < 0){	
					tt_nodes.push(data.nodes[jQuery.inArray(sId, full_node_id)]);
					tt_nodes_id.push(sId);			
					tt_links.push(e);				
				}		
			}
		
			if(tt_nodes.length == 0 ){			
				for(var j = 0; j < data.nodes.length;j++){				
					if(jQuery.inArray(data.nodes[j].id, nodes_id) < 0) {					
						tt_nodes.push(data.nodes[j]);
						tt_nodes_id.push(data.nodes[j].id);	
						d++;			
						break;
					}
				}
			}
			
			
			for(var i = 0; i < tt_nodes.length; i++){				
				var node = 	tt_nodes[i];			
				node.depth = d+1;
				node.fixed = false;		
				nodes_id.push(node.id);
				nodes.push(node);		
			}
	
			
			for(var i = 0; i < tt_links.length; i++){
				var e = tt_links[i];	
				t_links.splice(jQuery.inArray(e,t_links),1);
				
			}
		}
		nodes = data.nodes;
		links = t_links_1;
		
	
		return {nodes: nodes, links: links, root: root,depth:depth};
	}

	//function:findNode();
	function findNode(nodeId){
		for(var i = 0; i < net.nodes.length; i++){
			if(net.nodes[i].id == nodeId) {return net.nodes[i]};
		}	
		return null;
	}

	var translation = {'x':0, 'y':0};
	var node_text_threshold = 12;
	var show_keyword = {"id":"", "condition": false};
	var keyword_center = {};
	
	function resetShowKeyword(){
		show_keyword.id = "";
		show_keyword.condition = false;
		

		node.attr("opacity", 1);
	    nodeg.attr("pointer-events", "all");				
		link.attr("opacity", 1);
		linkg.attr("pointer-events", "all");		
		text.attr("opacity", 1);
		textg.attr("pointer-events", "all");
		draw_keyword_layer(false, "");
		
		
	}
	
	this.resetShowKeyword = resetShowKeyword;
	
	//function:redraw()
	function redraw(not_center_focus) {	
		force.stop();	
		net = network(data,net,root);	
		var depth = net.depth;	
		
	  	force.nodes(net.nodes)
		  	 .links(net.links)
		   	 .linkDistance(function(d) {return (10/d.value + 1.5) * (1/(1+Math.min(d.source.depth, d.target.depth) * 0.1)) *90; })   
		   	 .linkStrength( function(d) { return (1/(1+d.value)) } )
		     .charge(function(d){return -500; //return -2000/(Math.log(1+d.depth) + 1);
			 })
		   	 .gravity(0.2)
		     .start();
	  
		link = linkg.selectAll("line.link").data(net.links, function(d){return linkid(d)});
		link.enter().append("line")
			.attr("class", "link")
			.attr("x1", function(d) { return d.source.x; })
			.attr("y1", function(d) { return d.source.y; })
			.attr("x2", function(d) { return d.target.x; })
			.attr("y2", function(d) { return d.target.y; })
			.style("stroke-width", function(d) { return d.size?d.size:1; });
	  	link.exit().remove();
  
   		node = nodeg.selectAll("circle.node").data(net.nodes, function(d){return d.id;});    
		node.enter()
	   		.append("circle") 
			.attr("class", function(d) { return "node"; }) 
	   		.attr("r", function(d) {
				if(d.id == net.root.id)d.r = Math.max(Math.ceil(node_radius * Math.pow(2, 1.5)),2); 
				else d.r = Math.max(Math.ceil(node_radius * Math.pow(2, 1- d.depth/depth)),2); 
				return d.r; 
				})
			.attr("cx", function(d) { d.x = Math.max(d.r, Math.min(width - d.r, d.x)) ;  return d.x; })
			.attr("cy", function(d) { d.y = Math.max(d.r, Math.min(height - d.r, d.y)); return d.y; })
			.style("stroke-width", function(d){if(d.id == net.root.id) return 7;else return 1.5;})
			.style("fill", function(d){return fill(d.groupId);})
			.style("stroke", function(d){if(d.id == net.root.id) return d3.rgb(fill(d.groupId)).darker();});
		
		
	/*	node.on("dblclick", function(d,i) {
			d3.event.preventDefault();
			d3.event.stopPropagation();	
			console.log('node.dbclick');			
			resetRoot(d);
			if(navigator.userAgent.match(/Android/i) ) {show_details(d,i,this);}
		});	*/
		
		var click_num = 0;
		node.on("click", function(d,i) {
		
			d3.event.preventDefault();
			d3.event.stopPropagation();	
			
			
			
			click_num++;
			var tout = setTimeout(function(){
			
			if(click_num == 1){
			  click_num = 0;
						
			if(show_keyword.condition && show_keyword.id == d.id){
				show_keyword.condition = false;
				show_keyword.id = "";
				node.attr("opacity", 1);
				nodeg.attr("pointer-events", "all");				
				link.attr("opacity", 1);
				linkg.attr("pointer-events", "all");		
				text.attr("opacity", 1);
				textg.attr("pointer-events", "all");
				
				draw_keyword_layer(false, i);
			}
			else{// if(!show_keyword.condition){
				show_keyword.condition = true;
				show_keyword.id = d.id;				
				node.attr("opacity", 0.3);
			    nodeg.attr("pointer-events", "none");
				link.attr("opacity", 0);
				linkg.attr("pointer-events", "none");
				text.attr("opacity", 0);
				textg.attr("pointer-events", "none");				
				keyword_center = d;
				draw_keyword_layer(true, d);				
				resetRoot(d);
			}
			}// end of check of click_num
			else if(click_num <0){//>= 2){
				show_keyword.condition = false;
				show_keyword.id = "";
				node.attr("opacity", 1);
				nodeg.attr("pointer-events", "all");				
				link.attr("opacity", 1);
				linkg.attr("pointer-events", "all");		
				text.attr("opacity", 1);
				textg.attr("pointer-events", "all");
				draw_keyword_layer(false, i);
			}
			}, 400);//end of setInterval
		});	
		
		
		
		
		
		node
			//.on("touchstart", function(d){console.log('node.touchstart');resetRoot(d)})
			.on("mouseover", function(d,i){if(! navigator.userAgent.match(/Android/i) ) {console.log('node.mouseover');show_details(d,i,this)}})
			.on("mouseout", function(d,i){if(! navigator.userAgent.match(/Android/i) ) {console.log('node.mouseout');hide_details(d,i,this)}});	  
  
		node.exit().transition().ease("exp-in-out").attr("r", 0).remove ();  
		node.call(force.drag);	
	
		text = textg.selectAll("text.node").data(net.nodes, function(d){return "title"+d.id});
		text.enter().append("text")
		    .attr("class","node")
		    .attr("x", function(d){return d.x })
			.attr("x", function(d){return d.x })
			.attr("y", function(d) { return d.y})
	   		.attr("dx", -3) // padding-right
	   		.attr("dy", ".35em") // vertical-align: middle
	   		.attr("text-anchor", "middle") // text-align: right
	   		. text(function(d){
			//return html_entity_decode(d.name);
			if(d.id == net.root.id)d.r = Math.max(Math.ceil(node_radius * Math.pow(2, 1.5)),2); 
			else d.r = Math.max(Math.ceil(node_radius * Math.pow(2, 1- d.depth/depth)),2); 
			if(((screen_scale > 0 && screen_scale * d.r > node_text_threshold) || (screen_scale == 0 && d.r > node_text_threshold)) && d.visible ==true)return html_entity_decode(d.name); 
			else return "";
			});
	
	
		text.exit().remove();
		//text.call(force.drag);	
	
	/*	text.on("dblclick", function(d,i) {
			console.log('text.dbclick');
			d3.event.preventDefault();
		  	d3.event.stopPropagation();	
		  	resetRoot(d);
			if(navigator.userAgent.match(/Android/i) ) {show_details(d,i,this);}
		},false);*/	 
		
		
		text.on("click", function(d,i) {
		
			d3.event.preventDefault();
			d3.event.stopPropagation();	
			
			click_num++;
			var tout = setTimeout(function(){
			
			if(click_num == 1){
			  click_num = 0;

			if(show_keyword.condition && show_keyword.id == d.id){
				show_keyword.condition = false;
				show_keyword.id = "";
				node.attr("opacity", 1);
				nodeg.attr("pointer-events", "all");				
				link.attr("opacity", 1);
				linkg.attr("pointer-events", "all");		
				text.attr("opacity", 1);
				textg.attr("pointer-events", "all");
				
				draw_keyword_layer(false, i);
			}
			else{// if(!show_keyword.condition){
				show_keyword.condition = true;
				show_keyword.id = d.id;				
				node.attr("opacity", 0.3);
			    nodeg.attr("pointer-events", "none");
				link.attr("opacity", 0);
				linkg.attr("pointer-events", "none");
				text.attr("opacity", 0);
				textg.attr("pointer-events", "none");				
				keyword_center = d;
				draw_keyword_layer(true, d);		
				resetRoot(d);		
			}
			

			
			}// end of check of click_num
			else if(click_num <0){// >= 2){
				show_keyword.condition = false;
				show_keyword.id = "";
				node.attr("opacity", 1);
				nodeg.attr("pointer-events", "all");				
				link.attr("opacity", 1);
				linkg.attr("pointer-events", "all");		
				text.attr("opacity", 1);
				textg.attr("pointer-events", "all");
				draw_keyword_layer(false, i);
			}
			}, 400);//end of setInterval
		});	 
		
		
  
		text.on("mouseover", function(d,i){if(! navigator.userAgent.match(/Android/i) ) {console.log('text.mouseover');show_details(d,i,this)}})
	 		.on("mouseout", function(d,i){if(! navigator.userAgent.match(/Android/i) ) {console.log('text.mouseout');hide_details(d,i,this)}});	
	
		//if(translation.x != 0 || translation.y != 0){
		var distance = Math.sqrt(translation.x*translation.x + translation.y*translation.y);
		var trans_duration = distance *10;
		  
		//console.log('center:' + center.x + ':' + center.y);
		//console.log('translation:' + translation.x + ':' + translation.y);
		  
		var tx, ty;
		if(not_center_focus){tx = center_pre.x; ty = center_pre.y;}
		else{tx = center.x; ty = center.y;}
	  
		node.transition().duration(trans_duration)	
	  		.attr("transform", function(d) {return "translate(" + (-translation.x - width/2 + tx ) +  "," + (-translation.y - height/2 + ty) + ") "; })
	  		.transition().duration(500)
	  		//.attr("transform", function(d) {return "scale(" + 2 + ") "; })
	  		.attr("r", function(d) {
				if(d.id == net.root.id)d.r = Math.max(Math.ceil(node_radius * Math.pow(2, 1.5)),2); 
				else d.r = Math.max(Math.ceil(node_radius * Math.pow(2, 1- d.depth/depth)),2); 
				return d.r; })
			.style("fill", function(d){return fill(d.groupId);})
			.style("stroke-width", function(d){if(d.id == net.root.id) return 7;else return 1.5;})
			.style("stroke", function(d){if(d.id == net.root.id) return d3.rgb(fill(d.groupId)).darker();}) ;
	  
		/*node
		.transition().duration(trans_duration)
		.attr("transform", function(d) {return "translate(" + (-translation.x - width/2 + tx ) +  "," + (-translation.y - height/2 + ty) + ") "; })
		.transition().duration(500)
		.attr("width", function(d) { d.width = Math.max(Math.ceil(node_width * ( 1- 2*d.depth/depth)),8); return d.width + 2; })
		.attr("height", function(d) { d.height = Math.max(Math.ceil(node_height* ( 1- 2*d.depth/depth)),8);return d.height + 2; })
		.style("opacity", function(d){if(d.id == net.root.id) return 1;else return 0;});
		;*/
	  
		text.transition().duration(trans_duration)	
	  		.attr("transform", function(d) { return "translate(" + (-translation.x - width/2 + tx) +  "," + (-translation.y - height/2 + ty) + ")"; })	
			. text(function(d){
			//return html_entity_decode(d.name);
			if(d.id == net.root.id)d.r = Math.max(Math.ceil(node_radius * Math.pow(2, 1.5)),2); 
			else d.r = Math.max(Math.ceil(node_radius * Math.pow(2, 1- d.depth/depth)),2); 
			if(((screen_scale > 0 && screen_scale * d.r > node_text_threshold) || (screen_scale == 0 && d.r > node_text_threshold)) && d.visible == true)return html_entity_decode(d.name); 
			else return "";
			}); 
	  
	  
		link.transition().duration(trans_duration)	
	  		.attr("transform", function(d) { return "translate(" + (-translation.x - width/2 + tx) +  "," + (-translation.y - height/2 + ty) + ")"; })
			.style("stroke-width", function(d){
				if(d.source.visible && d.target.visible) { return d.size?d.size:1;}
				else return 0;			
		    })
			; 
			
			
		if(show_keyword.condition){
			knode.transition().duration(trans_duration)	
	  		.attr("transform", function(d) { return "translate(" + (-translation.x - width/2 + tx) +  "," + (-translation.y - height/2 + ty) + ")"; });
			klink.transition().duration(trans_duration)	
	  		.attr("transform", function(d) { return "translate(" + (-translation.x - width/2 + tx) +  "," + (-translation.y - height/2 + ty) + ")"; });
			ktext.transition().duration(trans_duration)	
	  		.attr("transform", function(d) { return "translate(" + (-translation.x - width/2 + tx) +  "," + (-translation.y - height/2 + ty) + ")"; });
		}
			
	  
		if(translation.x != 0 || translation.y != 0){
	  		if(draw_hull){
				if (!hull || first_draw_hull) {
					first_draw_hull = false;
					hullg.selectAll("path.hull").remove();
					hull = hullg.selectAll("path.hull")
								.data(convexHulls(net.nodes, getGroupId, off))
								.enter().append("path")
								.attr("class", "hull")
								.attr("d", drawCluster)
								.style("fill", function(d) { return fill(d.group); });
					hull.attr("transform", "translate(" + (-translation.x - width/2 + tx) +  "," + (-translation.y - height/2 + ty) + ")");
				}else{
					hull.transition().duration(trans_duration)	
						.attr("transform", "translate(" + (-translation.x - width/2 + tx) +  "," + (-translation.y - height/2 + ty) + ")"); 
				}
			}else{
				hullg.selectAll("path.hull").remove();
			}
		}else{
			if(draw_hull){
				first_draw_hull = false;
				hullg.selectAll("path.hull").remove();
				hull = hullg.selectAll("path.hull")
		  					.data(convexHulls(net.nodes, getGroupId, off))
		  					.enter().append("path")
		  					.attr("class", "hull")
		  					.attr("d", drawCluster)
		  					.style("fill", function(d) { return fill(d.group); });
		  	}else{
				hullg.selectAll("path.hull").remove();
		    }
		}
	  
		force.on("tick", function(){
				if(draw_hull){
				if (!hull.empty()){
					hull.data(convexHulls(net.nodes, getGroupId, off))
						.attr("d", drawCluster);
				}
			}
			
			link.attr("x1", function(d) { return d.source.x; })
		  		.attr("y1", function(d) { return d.source.y; })
		  		.attr("x2", function(d) { return d.target.x; })
		  		.attr("y2", function(d) { return d.target.y; });
			
			node.attr("cx", function(d) { return d.x ; })
				.attr("cy", function(d) { return d.y ; });
			
			text.attr("x", function(d) { return d.x ; })
				.attr("y", function(d) { return d.y ; });
				
				
			if(show_keyword.condition){
				update_keyword_layer (keyword_center);
			}
			
			
		});
	
		if(!not_center_focus){
	  		center_pre.x = center.x ;
	  		center_pre.y = center.y;
		}  
	}//end of redraw
	
	var klink,knode,ktext;
	
	function update_keyword_layer (anchor_point){
			/*knode.attr("cx", function(d,i) { d.x = anchor_point.x +  radius * Math.cos(angle*i) ;   return d.x})
						.attr("cy", function(d,i) {d.y = anchor_point.y +  radius * Math.sin(angle*i) ;return d.y; });*/
						
			knode.attr("x", function(d,i) { d.x = anchor_point.x +  radius * Math.cos(angle*i) ; return d.x - d.width/2;})
						.attr("y", function(d,i) {d.y = anchor_point.y +  radius * Math.sin(angle*i);  return d.y-d.height/2; });
			
				klink.attr("x1", function(d) {
								if(d.level == 1){d.source.x = anchor_point.x; return d.source.x; }
								else if(d.level == 2){
									net.nodes.forEach(function(inode){if(inode.id == d.source.id){d.source.x = inode.x;}});  
								return d.source.x; }
								})
							.attr("y1", function(d) { 
								if(d.level == 1){d.source.y = anchor_point.y; return d.source.y; }
								else if(d.level == 2){
									net.nodes.forEach(function(inode){if(inode.id == d.source.id) d.source.y = inode.y;});  
								return d.source.y; }
							})
						.attr("x2", function(d) { return d.target.x;})
						.attr("y2", function(d) { return d.target.y;});
			
				ktext.attr("x", function(d){return d.x ;})
					       .attr("y", function(d) { return d.y});
	}
	
	var radius ;
	var angle;
	

	function draw_keyword_layer(show, anchor_point){
	
		var keyword_list = [];
		var filteredLink = [];
		var filteredData = [];
		
		var knode_mousedown = {};
		var hasKnodeDown = false;
			
		if(show){
	
	/*	if(knode){
		keyword_nodeg.remove(knode);
		keyword_linkg.remove(klink);
		keyword_textg.remove(ktext);
		}*/
		
	//	knode = keyword_nodeg.selectAll("circle.knode").data([]);    //function(d){return d.id}
		knode = keyword_nodeg.selectAll("image.knode").data([]);   
		knode.exit().remove();
		klink = keyword_linkg.selectAll("line.klink").data([]);
		klink.exit().remove();
		ktext = keyword_textg.selectAll("text.ktext").data([]);
		ktext.exit().remove();

		var remain_links = [];
		
		keyword_data.links.forEach(function(d){
			if(!d.source.id){
				d.source = keyword_data.nodes[d.source];
				d.target = keyword_data.nodes[d.target];
			}
			
			if(d.source.id == anchor_point.id && d.target.label != "family"){		
				d.level = 1;
				keyword_list.push(d.target.id);
				filteredLink.push(d);		
			}
			else remain_links.push(d);		
		});

		remain_links.forEach(function(d){if($.inArray(d.target.id, keyword_list)!=-1){d.level = 2; filteredLink.push(d);}});		
		
		filteredData = keyword_data.nodes.filter(function(d){
			if(d.type == "keyword" && $.inArray(d.id, keyword_list) != -1 && d.label != "family") {return true};
		});  
		};

  		
		angle = 2 * Math.PI/filteredData.length;
		radius = 70;
	
  	/*	knode = keyword_nodeg.selectAll("circle.knode").data(filteredData);    //function(d){return d.id}
		knode.enter()
	   		.append("circle") 
			.attr("class", "knode" ) 
	   		.attr("r", function(d) {console.log(d.name); return 15;})
			//.attr("height", function(d) { return 20;})
			.attr("cx", function(d,i) { d.x = anchor_point.x +  radius * Math.cos(angle*i) ;   return d.x})
			.attr("cy", function(d,i) {d.y = anchor_point.y +  radius * Math.sin(angle*i) ;return d.y; })
			.style("stroke-width", function(d){return 1;})
			.style("fill", function(d){return "#AAA";})
			.style("stroke", function(d){ return d3.rgb("red").darker();});*/
			
		  
  		knode = keyword_nodeg.selectAll("image.knode").data(filteredData);    //function(d){return d.id}
		knode.enter()
					.append("image") 
    				  .attr("class", function(d) { return "knode"; }) 
     				  .attr("width", function(d) { d.width = 46; return d.width; })
	                  .attr("height", function(d) {d.height = 46; return d.height; })
                     .attr("x", function(d,i) {  d.x = anchor_point.x +  radius * Math.cos(angle*i) ;  return d.x -d.width/2; })
                     .attr("y", function(d,i) { d.y = anchor_point.y +  radius * Math.sin(angle*i) ;  return d.y-d.height/2; })      
	                 .attr("xlink:href", function(d){
					 	switch(d.label){
							case "country": return "images/country.png"; break;
							case "grapeTypes": return "images/grape.png"; break;
							case "region": return "images/region.png"; break;
							case "genre": return "images/genre.png"; break;
							case "producer": return "images/producer.png"; break;							
						}
			});

			
			
		knode.exit().remove();
		
		knode.on("mouseover", function(d,i){
			var nd = d3.select(this);
			 if(hasKnodeDown === false){
			var neighbors = [];
			nd.style("fill","yellow");
			
			var pic;
			switch(d.label){
							case "country": pic= "images/country_click.png"; break;
							case "grapeTypes": pic= "images/grape_click.png"; break;
							case "region": pic= "images/region_click.png"; break;
							case "genre": pic= "images/genre_click.png"; break;
							case "producer": pic= "images/producer_click.png"; break;							
			}			
			nd.attr("xlink:href",pic);
			
			
			
			
			klink.style("stroke-width", function(dt) {
				if(dt.target.id == d.id && dt.level == 2){ neighbors.push(dt.source.id);return 0;}
				else if(dt.level == 2)return 0;
			//	else return 1;				 
				 })
			klink.style("stroke", function(dt) {
			//	if(dt.target.id == d.id && dt.level == 2){return "green";}	
			if(dt.level == 2){return "green";}	
				 });
				 
			node.style("opacity", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){return 1;}})
		          .attr("pointer-events", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){ return "all";}});
				  
		    text.style("opacity", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){ return 1;}})
		          .attr("pointer-events", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){ return "all";}});
			}
			});
			
		knode.on("mouseout", function(d,i){
			var nd = d3.select(this);
			
		
			 if(hasKnodeDown === false){
			nd.style("fill","#AAA");
			klink.style("stroke-width", function(dt) {
				if(dt.level == 2){return 0;}				 
				 });
				 
				 
			var pic;
			switch(d.label){
							case "country": pic= "images/country.png"; break;
							case "grapeTypes": pic= "images/grape.png"; break;
							case "region": pic= "images/region.png"; break;
							case "genre": pic= "images/genre.png"; break;
							case "producer": pic= "images/producer.png"; break;							
			}			
			nd.attr("xlink:href",pic);
				 
				 
			node.style("opacity", function(dt){if( dt.id == anchor_point.id){console.log(dt.id);return 1;}})
		          .attr("pointer-events", function(dt){if(dt.id == anchor_point.id){ return "all";}});
				  
		    text.style("opacity", function(dt){if(dt.id == anchor_point.id){ return 1;}})
		          .attr("pointer-events", function(dt){if(dt.id == anchor_point.id){ return "all";}});
			}
			});
			
			
	
			
		knode.on("click", function(d,i){
			var nd = d3.select(this);
		//	if(!knode_mousedown[i] && !hasKnodeDown)
		
		if(typeof variable === 'undefined' || !knode_mousedown[i])
			{
		    
			//console.log(knode_mousedown);
			  knode.attr("xlink:href", function(dt,it){
			//  return "images/country_click.png"; 
				//	console.log(knode_mousedown[it] + ":" + it + ":" + i);
				 if( it != i){//knode_mousedown[it] &&
						knode_mousedown[it] = false;
					
					 	switch(dt.label){
							case "country": return "images/country.png"; break;
							case "grapeTypes": return "images/grape.png"; break;
							case "region": return "images/region.png"; break;
							case "genre": return "images/genre.png"; break;
							case "producer": return "images/producer.png"; break;							
						}				
						
					
					}
					else{
						
						 if(it == i){
						switch(dt.label){
							case "country": return "images/country_click.png"; break;
							case "grapeTypes": return "images/grape_click.png"; break;
							case "region": return "images/region_click.png"; break;
							case "genre": return "images/genre_click.png"; break;
							case "producer": return "images/producer_click.png"; break;		
						}
						}					
					}
				});
			

			var neighbors = [];
			nd.style("fill","yellow");
			klink.style("stroke-width", function(dt) {
				if(dt.target.id == d.id && dt.level == 2){ neighbors.push(dt.source.id);return 0;}
				else if(dt.level == 2)return 0;
			//	else return 1;				 
				 })
			klink.style("stroke", function(dt) {
				if(dt.target.id == d.id && dt.level == 2){return "green";}						 
				 });
				 
			node.style("opacity", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){return 1;}})
		          .attr("pointer-events", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){ return "all";}});
				  
		    text.style("opacity", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){ return 1;}})
		          .attr("pointer-events", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){ return "all";}});
			knode_mousedown[i] = true;
			hasKnodeDown = true;			  
			
			}else if(knode_mousedown[i]){
		
			nd.style("fill","#AAA");
			klink.style("stroke-width", function(dt) {
				if(dt.level == 2){return 0;}				 
				 });
				 
			node.style("opacity", function(dt){if( dt.id == anchor_point.id){return 1;}})
		          .attr("pointer-events", function(dt){if(dt.id == anchor_point.id){ return "all";}});
				  
		    text.style("opacity", function(dt){if(dt.id == anchor_point.id){ return 1;}})
		          .attr("pointer-events", function(dt){if(dt.id == anchor_point.id){ return "all";}});
						
			knode_mousedown[i] = false;
			hasKnodeDown = false;	
			}
			
			});
			
			
			
		klink = keyword_linkg.selectAll("line.klink").data(filteredLink);//, function(d){return linkid(d)}
		klink.enter().append("line")
			.attr("class", "klink")
			.attr("x1", function(d) { 
				if(d.level == 1){d.source.x = anchor_point.x; return d.source.x; }
				else if(d.level == 2){
				net.nodes.forEach(function(inode){if(inode.id == d.source.id){d.source.x = inode.x;}});  
				return d.source.x; }
				})
			.attr("y1", function(d) { 
				if(d.level == 1){d.source.y = anchor_point.y; return d.source.y; }
				else if(d.level == 2){
					net.nodes.forEach(function(inode){if(inode.id == d.source.id) d.source.y = inode.y;});  
				//console.log("[" + d.source.x+ "," +d.source.y + "][" + d.target.x + "," + d.target.y + "]"); 
					return d.source.y; }
				})
			.attr("x2", function(d) { 
				return d.target.x; 		
				})
			.attr("y2", function(d) { 			
				return d.target.y; 
				})
			.style("stroke-width", function(d) {
				 if(d.level != 1)return 0; 
				 });
	  	klink.exit().remove();
		
		ktext = keyword_textg.selectAll("text.ktext").data(filteredData);//, function(d){return "title"+d.id}
		ktext.enter().append("text")
		    .attr("class", "ktext" ) 
			.attr("x", function(d){return d.x})
			.attr("y", function(d) { return d.y})
	   		.attr("dx", function(d,i){
				//if(i <= filteredData.length/8 || i >= 7 *filteredData.length/8) return 30; 
				if(i < filteredData.length/4|| i > 3 *filteredData.length/4) return 30; 
			//	else if(i >=3* filteredData.length/8 && i <= 5 *filteredData.length/8) return -30;
			   else if(i > filteredData.length/4 && i <3 *filteredData.length/4) return -30;
				else return -2;
				}) // padding-right 2
	   		.attr("dy", function(d,i){
				if(i >= filteredData.length/8 && i <= 3 *filteredData.length/8) return 40;
				else if(i >=5* filteredData.length/8 && i <= 7 *filteredData.length/8) return -30;
				else return 3.5;			
			}) // vertical-align: middle 0.35em
	   	    .attr("text-anchor",function(d,i){
				if(i <filteredData.length/8 || i >7 *filteredData.length/8) return "start"; 
				else if(i >3* filteredData.length/8 && i < 5 *filteredData.length/8) return "end";
				else return "middle";
			}) // text-align: right
	   		. text(function(d){	return  html_entity_decode(d.name);});
			
		ktext.exit().remove();
		
			ktext.on("mouseover", function(d,i){
			var nd =d3.select(knode[0][i]);

			 if(hasKnodeDown === false){
			var neighbors = [];
			nd.style("fill","yellow");
			klink.style("stroke-width", function(dt) {
				if(dt.target.id == d.id && dt.level == 2){ neighbors.push(dt.source.id);return 0;}
				else if(dt.level == 2)return 0;
			//	else return 1;				 
				 })
			klink.style("stroke", function(dt) {
			//	if(dt.target.id == d.id && dt.level == 2){return "green";}	
			if(dt.level == 2){return "green";}	
		 
				 });
				 
			node.style("opacity", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){return 1;}})
		          .attr("pointer-events", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){ return "all";}});
				  
		    text.style("opacity", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){ return 1;}})
		          .attr("pointer-events", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){ return "all";}});
			}
			})
			
		ktext.on("mouseout", function(d,i){
			var nd =d3.select(knode[0][i]);
		
			 if(hasKnodeDown === false){
			nd.style("fill","#AAA");
			klink.style("stroke-width", function(dt) {
				if(dt.level == 2){return 0;}				 
				 });
				 
			node.style("opacity", function(dt){if( dt.id == anchor_point.id){return 1;}})
		          .attr("pointer-events", function(dt){if(dt.id == anchor_point.id){ return "all";}});
				  
		    text.style("opacity", function(dt){if(dt.id == anchor_point.id){ return 1;}})
		          .attr("pointer-events", function(dt){if(dt.id == anchor_point.id){ return "all";}});
			}
			});
				
			
		ktext.on("click", function(d,i){
			var nd =d3.select(knode[0][i]);
	
			if(!knode_mousedown[i] && !hasKnodeDown)
			{

			var neighbors = [];
			nd.style("fill","yellow");
			klink.style("stroke-width", function(dt) {
				if(dt.target.id == d.id && dt.level == 2){neighbors.push(dt.source.id); return 0;}
				else if(dt.level == 2)return 0;
			//	else return 1;				 
				 })
			klink.style("stroke", function(dt) {
				if(dt.target.id == d.id && dt.level == 2){return "green";}	
 
				 });
				 
			node.style("opacity", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){return 1;}})
		          .attr("pointer-events", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){ return "all";}});
				  
		    text.style("opacity", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){ return 1;}})
		          .attr("pointer-events", function(dt){if($.inArray(dt.id, neighbors) != -1 || dt.id == anchor_point.id){ return "all";}});
			knode_mousedown[i] = true;
			hasKnodeDown = true;			  
			
			}else if(knode_mousedown[i]){
		
			nd.style("fill","#AAA");
			klink.style("stroke-width", function(dt) {
				if(dt.level == 2){return 0;}				 
				 });
				 
			node.style("opacity", function(dt){if( dt.id == anchor_point.id){return 1;}})
		          .attr("pointer-events", function(dt){if(dt.id == anchor_point.id){ return "all";}});
				  
		    text.style("opacity", function(dt){if(dt.id == anchor_point.id){ return 1;}})
		          .attr("pointer-events", function(dt){if(dt.id == anchor_point.id){ return "all";}});
						
			knode_mousedown[i] = false;
			hasKnodeDown = false;	
			}			
			});
	
		
		node.style("opacity", function(d){if(d.id == anchor_point.id){ return 1;}})
		          .attr("pointer-events", function(d){if(d.id == anchor_point.id){ return "all";}});
				  
		text.style("opacity", function(d){if(d.id == anchor_point.id){ return 1;}})
		          .attr("pointer-events", function(d){if(d.id == anchor_point.id){ return "all";}});
			
		//	keyword_animation(index);
		
	var transform = node.attr("transform");
		knode.attr("transform", function(d) { return transform})	
					 .style("fill", function(d){return "#AAA";});
		klink.attr("transform", function(d) { return transform; })	;			
		ktext.attr("transform", function(d) { return transform; })	;
	}
	
	
	//function:resetRoot()
	function resetRoot(d){
		root = d;
		translation.x = d.x - width/2;
		translation.y = d.y - height/2;
		filters = {};
		//show_keyword.condition = false;
		//show_keyword.id = "";
		
	//	show_keyword = {"id":"", "condition": false};
	//    keyword_center = {};
		
		redraw(0);
		showProductPanel(root);
		showCritiquingPanel(root)
	}
	
	var filters = {};

	
	//function:show_details
	function show_details(data, i, element){	
		content = "<table width=\"100%\" height=\"100%\" cellpadding=\"0\" cellspacing=\"0\">";
	 	content += "<tr>";
	 	content += "<td><img src = \"" + data.img + "\" width=\"60\"  ></td>"
	 	content += "<td>";
	 
	 	content += "<table width=\"100%\"  cellpadding=\"0\" cellspacing=\"0\">";
	 	content += "<tr><td width=\"30%\" class=\"name\">Name:</td><td class=\"value\">" +  (data.name?data.name:"")+ "</td></tr>";
	 	content += "<tr><td class=\"name\">Grape(s):</td><td class=\"value\">" + (data.grapeTypes?data.grapeTypes:"")+ "</td></tr>";
	 	content += "<tr><td class=\"name\">Country of origin:</td><td class=\"value\">" +  (data.country?data.country:"")+ "</td></tr>";
	  	content += "<tr><td class=\"name\">Region:</td><td class=\"value\">" + (data.region?data.region:"")+ "</td></tr>";
		content += "<tr><td class=\"name\">Type:</td><td class=\"value\">" +  (data.genre?data.genre:"")+ "</td></tr>";
	 	//content += "<tr><td class=\"name\">Family:</td><td class=\"value\">" +  (data.family?data.family:"")+ "</td></tr>";
		content += "<tr><td class=\"name\">Producer:</td><td class=\"value\">" + (data.producer?data.producer:"")+ "</td></tr>";
		content += "<tr><td class=\"name\">Price:</td><td class=\"value\">" +  (data.price?data.price + " CHF":"")+ "</td></tr>";
		content += "<tr><td class=\"name\">Rating:</td><td class=\"value\">" + (data.rating?data.rating:"")+ "</td></tr>";
	 	//content += "<tr><td class=\"name\">Node Depth:</td><td class=\"value\">" +  data.depth+ "</td></tr>";  
		
		content += "</table>";
		content += "</td></tr></table>";
		 
    	tooltip.showTooltip(content,d3.event)
	} 

	//function: hide_details
	function hide_details (data, i, element){
		tooltip.hideTooltip();
	} 

	var pmouse_location = {'x':null,'y':null};
	var startDrag = false;

	//function: mousedown
	function mousedown(){			
		//var p = d3.svg.mouse(self.vis[0][0]),
		//	t = d3.event.changedTouches;
		d3.select('#viewer').style("cursor","move");	
		//	pmouse_location.x = p[0];
		//	pmouse_location.y = p[1];	
		//	startDrag = true;
	}

	//function: mousemove
	function mousemove(){	
	
		if(!startDrag)return;
		var p = d3.svg.mouse(self.vis[0][0]),
			t = d3.event.changedTouches;
	
		translation.x += pmouse_location.x - p[0];
		translation.y += pmouse_location.y - p[1];
	
		pmouse_location.x = p[0];
		pmouse_location.y = p[1];	
	
		//d3.event.preventDefault();
		//d3.event.stopPropagation();
	
		redraw(0);
	};

	//function: mouseup
	function mouseup(){
		d3.select('#viewer').style("cursor","auto");
		//startDrag = false;		
		//pmouse_location.x = null;
		//pmouse_location.y = null;
	};
	
	this.resetRoot = resetRoot;
	this.redraw = redraw;
	this.findNode = findNode;
	this.redetermineGroup = redetermineGroup;
	this.init = init;
	
}//end of SemanticViewer

/*
SemanticView.prototype.update = function(){
	var self = this;
}

SemanticView.prototype.plot_drag = function(){
	var self = this;
	return function(){		
		registerKeyboardHandler(self.keydown());
		d3.select('body').style("cursor","move");		
	}
};*/

/*SemanticView.prototype.mousedown = function(){
	var self = this;
	return function(){			
	    var p = d3.svg.mouse(self.vis[0][0]),
		    t = d3.event.changedTouches;
		d3.select('body').style("cursor","move");	
		self.pmouse_location.x = p[0];
		self.pmouse_location.y = p[1];	
	}
};


SemanticView.prototype.mousemove = function(){
	var self = this;
	return function(){		
		var p = d3.svg.mouse(self.vis[0][0]),
		    t = d3.event.changedTouches;
			
		
			
		console.log(t +':' + p[0] + ':' + p[1]);
		
		
		d3.event.preventDefault();
		d3.event.stopPropagation();
			
	}
};

SemanticView.prototype.mouseup = function(){
	var self = this;
	return function(){
		document.onselectstart = function(){return true;};
		d3.select('body').style("cursor","auto");
		
		if(!isNaN(self.downx)){
			//self.redraw();
			self.downx = Math.NaN;
			d3.event.preventDefault();
			d3.event.stopPropagation();
		}
		
		if(!isNaN(self.downy)){
			//self.redraw();
			self.downy = Math.NaN;
			d3.event.preventDefault();
			d3.event.stopPropagation();
		}
		
		if(self.dragged){
			self.dragged = null;
		}		
	}
}*/

/*
SemanticView.prototype.keydown = function(){
	var self = this;
	return function(){
		if(!self.selected) return;
		switch(d3.event.keyCode){
			case 8: //backspace
			case 46: {//delete
			}
		}
	}

};*/
/*

SemanticView.prototype.redraw = function(){
	var self = this;
	return function(){}
}*/

/*
SemanticView.prototype.xaxis_drag = function(){
	var self = this;
	return function(d){
		document.onselectstart = function(){return false;};
		var p = d3.svg.mouse(self.vis[0][0]);
		self.downx = p[0];
	}
}

SemanticView.prototype.yaxis_drag = function(){
	var self = this;
	return function(d){
		document.onselectstart = function(){return false;};
		var p = d3.svg.mouse(self.vis[0][0]);
		self.downy = p[1];
	}
}*/

var semanticview;
var options ={};
	

//main function
$(document).ready(function(){	
	semanticview = new SemanticView("viewer", options);
	semanticview.init();
	/*
	var communityBtn = $("#communityEnableBtn");
	communityBtn.click(function(){	
		if(communityBtn.attr("value") == "Enable"){
			semanticview.setDrawHull(true);
			communityBtn.attr("value", "Disable");			
			semanticview.redraw(1);
		}else{			
			semanticview.setDrawHull(false);
			communityBtn.attr("value","Enable");
			semanticview.redraw(1);
		}
	});*/
});




</script>

	<div id="result"></div>
	<pre id="mypre"></pre>
</body>
</html>
